from __future__ import annotations

from typing import Any, Literal, Optional, Union

TrackKind = Literal["video", "audio", "other"]
OverlapPolicy = Literal["override", "push"]
InsertPolicy = Literal[
    "split_and_insert", "insert_before", "insert_after", "insert_before_or_after"
]

class MediaSource:
    def __init__(self, url: str) -> None: ...
    def get_url(self) -> str: ...
    def set_url(self, value: str) -> None: ...
    def get_media_start(self) -> float: ...
    def set_media_start(self, value: float) -> None: ...
    def get_media_duration(self) -> Optional[float]: ...
    def set_media_duration(self, value: Optional[float]) -> None: ...

class Clip:
    def __init__(
        self, duration: float, source: MediaSource, name: Optional[str] = None
    ) -> None: ...
    def get_name(self) -> Optional[str]: ...
    def set_name(self, value: Optional[str]) -> None: ...
    def get_duration(self) -> float: ...
    def set_duration(self, value: float) -> None: ...
    def get_source(self) -> MediaSource: ...
    def set_source(self, value: MediaSource) -> None: ...

class Gap:
    def __init__(self, duration: float) -> None: ...
    def get_duration(self) -> float: ...
    def set_duration(self, value: float) -> None: ...

class Item:
    @staticmethod
    def from_clip(c: Clip) -> Item: ...
    @staticmethod
    def from_gap(g: Gap) -> Item: ...
    def is_clip(self) -> bool: ...
    def is_gap(self) -> bool: ...
    def duration(self) -> float: ...
    def set_duration(self, dur: float) -> None: ...

class Track:
    def __init__(self, kind: Optional[TrackKind] = None) -> None: ...
    @property
    def kind(self) -> TrackKind: ...
    @kind.setter
    def kind(self, value: TrackKind) -> None: ...
    def items(self) -> list[Item]: ...
    def clear_items(self) -> None: ...
    def sanitize(self) -> None: ...
    def append(self, item: Union[Item, Clip, Gap]) -> None: ...
    def insert_at_index(
        self, index: int, item: Union[Item, Clip, Gap], overlap_policy: OverlapPolicy
    ) -> None: ...
    def insert_at_time(
        self,
        start_time: float,
        item: Union[Item, Clip, Gap],
        overlap_policy: OverlapPolicy,
        insert_policy: InsertPolicy,
    ) -> None: ...
    def split_at_time(self, time: float) -> None: ...
    def get_item_at_time(self, time: float) -> Optional[int]: ...
    def get_item_by_id(self, id: str) -> Optional[tuple[int, Item]]: ...
    def replace_item(self, index: int, item: Union[Item, Clip, Gap]) -> bool: ...
    def delete_clip(self, index: int, replace_with_gap: bool) -> bool: ...
    def resize_item(
        self,
        index: int,
        new_start_time: float,
        new_duration: float,
        overlap_policy: OverlapPolicy,
        clamp_to_media: bool,
    ) -> bool: ...
    def total_duration(self) -> float: ...
    def start_time_of_item(self, index: int) -> float: ...
    def insert_clip(
        self,
        start_time: float,
        duration: float,
        url: str,
        overlap_policy: OverlapPolicy,
        insert_policy: InsertPolicy,
        name: Optional[str] = None,
        media_start: Optional[float] = None,
        media_duration: Optional[float] = None,
    ) -> None: ...

class Stack:
    def __init__(self) -> None: ...
    def tracks(self) -> list[Track]: ...
    def children(self) -> list[Track]: ...
    def clear_children(self) -> None: ...
    def add_track(self, track: Track) -> None: ...
    def set_tracks(self, tracks: list[Track]) -> None: ...
    def sanitize(self) -> None: ...

class Timeline:
    def __init__(self) -> None: ...
    @staticmethod
    def parse_json(s: str) -> Timeline: ...
    def to_json(self) -> str: ...
    def validate(self) -> list[str]: ...
    def sanitize(self) -> None: ...
    def get_name(self) -> Optional[str]: ...
    def set_name(self, value: Optional[str]) -> None: ...
    def get_stack(self) -> Stack: ...
    def set_stack(self, stack: Stack) -> None: ...
